---
title: >
  L’IA comme algorithme — l’illusion de transparence
breadcrumb_title: "L’IA comme algorithme — l’illusion de transparence"
url: "/manifeste-technorealiste-sur-lia/a-lencontre-de-quelques-lubies-dominantes-sur-lia/des-notions-contestables-inutiles-voire-trompeuses/lia-comme-algorithme/"
slug: "lia-comme-algorithme"
aliases:
  - /manifeste-technorealiste-sur-lia/lia-comme-algorithme/
  - /manifeste-technorealiste-sur-lia/a-lencontre-de-quelques-lubies-dominantes-sur-lia/lia-comme-algorithme/

full_width: false
design:
  full_width: false
  toc:
    present: true
    offcanvas: false

position: 1
weight: 1
translation_key: communication-website-page-2c6142e3-18fc-4750-af0e-36b902d867b9

bodyclass: 

meta_description: >
  
description: >
  

summary: >
  “Algorithme” n’est pas un bon terme, parce qu’il suggère que la “recette dans le livre” est la même chose que “l’action de cuisiner réellement”
description_short: >
  “Algorithme” n’est pas un bon terme, parce qu’il suggère que la “recette dans le livre” est la même chose que “l’action de cuisiner réellement”

header_text: >-
  
contents_reading_time:
  seconds: 273
  text: >-
    5 minutes
contents:
  - kind: heading
    title: >-
      Définition courante
    position: 1
    level: 2
  - kind: block
    template: chapter
    title: >-
      
    position: 1
    data:
      layout: no_background
      text: >-
        <p>Un algorithme est la description d'une suite d’instructions permettant d'obtenir un résultat à partir d'éléments fournis en entrée (donc une série de règles ou d'instructions étape par étape qui guident le processus de prise de décision ou de résolution de problèmes). La notion d’algorithme permet de décrire une logique théorique d’un traitement de données. En IA, spécifiquement, l’algorithme peut être défini comme une série d'instructions opératoires décrites par des formules mathématiques, et dont le but est de réduire l'erreur par modification automatique des poids dans un modèle. </p>

      notes: >-
        


      alt: >-
        

      credit: >-
        




  - kind: heading
    title: >-
      Points d’attention
    position: 2
    level: 2
  - kind: block
    template: chapter
    title: >-
      
    position: 1
    data:
      layout: no_background
      text: >-
        <p>Il a quelque part été relevé que l’usage public du mot “algorithme” relève d’une “utilisation trop simplifiée. </p><p>Nous le confirmons: dans un ordinateur, on a du mal à identifier ce qu’est un algorithme. En tant que “suite d’instructions”, l’algorithme en toute rigueur devrait être fini… mais au contraire, un ordinateur fonctionne grâce à des programmes, qui peuvent opérer des boucles de traitement, et donc travailler de manière in(dé)finie! Autre distance algorithme/programme: alors que l’algorithme est une suite théorique d’instructions, une procédure générale, un programme c’est l’écriture de ces instructions dans un langage de programmation particulier. On dit qu’un programme implémente un ou plusieurs algorithmes.</p><p>Nous devons alors insister sur le caractère abstrait de l’algorithme, qui suppose d’ignorer les détails d’implémentation (choix du langage et du cadre (framework) de programmation, architecture logiciel, clustering etc).</p><p>Parler d’algorithme, c’est choisir le seul regard du logicien, qui est loin d’épuiser la réalité: d’autres regards complémentaires sont nécessaires pour parler un peu mieux du réel (le regard de l’utilisateur, de l'administrateur, du programmeur etc.)</p><p>Le programme et l’algorithme ne sont pas déterministes de la même manière, au sens où le programme est soumis à modification en cas de changement de variables. Un programme peut certes “embarquer“ certaines séquences de code, non changeantes, qualifiables d’algorithmes. Mais selon certains auteurs, on ne doit parler d’algorithme qu’à un stade de réduction avancée. Quoi qu’il en soit, la notion de programme appelle celle de finitude ou non-terminaison.</p><p>La non-terminaison inhérente au traitement de programmes implique que l'opcode devant être exécuté peut être conservé dans un compteur de programme, qui est ensuite incrémenté de manière séquentielle après l'exécution de chaque opcode. Cependant, certains opcodes, tels que les instructions de saut (jump), ont la capacité de modifier la valeur du compteur de programme, ce qui peut entraîner une boucle d'exécution: on comprend ici que si un programme mettait un temps infini pour donner une réponse, il ne servirait potentiellement à rien…  Pourtant le temps d’exécution (uptime) est paramétrable et on récupère ici, un caractère de finitude typique de l’algorithme. </p>

      notes: >-
        


      alt: >-
        

      credit: >-
        




  - kind: heading
    title: >-
      Erreurs communes
    position: 3
    level: 2
  - kind: block
    template: chapter
    title: >-
      
    position: 1
    data:
      layout: no_background
      text: >-
        <p>Le problème théorique de finitude algorithmique est toujours négligé, de sorte que ce que nous lisons partout, suggère que l’algorithme serait une sorte de petite machine opératoire, ce qui est très faux si on a lu nos développements sur l’opcode. Or nous l’avons vu: lorsque l'ensemble des étapes algorithmiques (y compris les appels aux autres algorithmes) n’est pas bien défini, est ambigu, ne se termine pas, ou ne vise pas à résoudre un problème spécifique, on ne devrait pas parler d’algorithme.</p><p>“Algorithme” est le plus souvent employé pour désigner en fait, le “programme”. Or un programme qui “boucle” met un temps infini, et donc ne peut plus être qualifié d’algorithme.</p><p>Le travail des juristes, publicitaires et éthiciens, en insistant sur la mauvaise qualité des algorithmes, ou leur caractère éventuellement discriminatoire, nous trompe: ils inventent un monde imaginaire, où il y aurait des “machines algorithmiques” que l’on pourrait caractériser, dont on pourrait reconnaître les effets, et donc améliorer. Par exemple, lorsqu’on s’intéresse au caractère discriminatoire du soi-disant algorithme de Parcoursup (en fait, la partie informatisée du processus), on cesse d’envisager cela, que ladite discrimination peut provenir des données, du modèles, ou encore du simple fait d’utiliser l’informatique. On voit que l’algorithme a bon dos. </p><p>Tout aussi trompeur: les réflexions sur la “gouvernance algorithmique”, qui suggèrent quelqu’un choisissant les mauvais algorithmes, ou les contrôlant. Ce n’est pas réel: il y a en revanche des gens (les informaticiens) qui s’occupent des programmes logiciels, et leur travail ne se résume nullement au choix entre les meilleures et les moins bonnes petites “machines algorithmiques”.</p><p>ll n’y a dans la réalité que des ordinateurs, sur lesquels tournent principalement des programmes, et par exception quelques rares algorithmes, sauf à employer une définition très large qui en perd le sens, et la notion clé de terminaison.</p>

      notes: >-
        


      alt: >-
        

      credit: >-
        




  - kind: heading
    title: >-
      Proposition
    position: 4
    level: 2
  - kind: block
    template: chapter
    title: >-
      
    position: 1
    data:
      layout: no_background
      text: >-
        <p>“Algorithme” peut convenir, dans des situations très spécifiques: par exemple, l’algorithme GPT de ChatGPT pourrait être assimilé à une “intelligence” (en fait, une fonction calculatoire) de type algorithmique, parce qu'elle utilise un réseau de neurones mais aussi car elle est capable de faire le lien entre certains domaines sémantiques non apparemment corrélés.</p><p>Il faudrait réserver le terme algorithme à certains cas, comme lorsqu’il s’agit de désigner les suites finies de calculs au cours de la phase d’entraînement. Mais pour le reste, en particulier à partir de la mise en production, on devrait plutôt parler du programme. Le programme, c’est ce qui est présent dans les ordinateurs réels: dans certains cas seulement, le programme est déterministe au sens que l’on peut connaître à l’avance quelles informations viendront s’ajouter lors de son exécution. Dans ces cas seulement, on pourrait éventuellement parler d’algorithmes.</p><p>Il faudrait encore ici se méfier : la modification du programme peut être “connue” comme aléatoire (étant précisé que l’aléa en informatique est simulé à partir de techniques, logicielles ou matérielles particulières). Dans ce cas encore, il redevient contestable et trompeur de parler d’algorithme.</p>

      notes: >-
        


      alt: >-
        

      credit: >-
        





---
